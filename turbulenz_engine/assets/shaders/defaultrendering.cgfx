// Copyright (c) 2009-2015 Turbulenz Limited

#include "platform.cgh"

#include "skinning.cgh"
#include "uvtransform.cgh"

//
// Uniform variables
//
float4x4 worldViewProjection;
float3x3 worldInverseTranspose;

float3 eyePosition; // in local space

float3 lightPosition; // in local space
float3 lightColor;
float3 ambientColor;

float4 materialColor = {1.0, 1.0, 1.0, 1.0};

float alphaRef = 0.5;
float lightingScale = 2.0;

static const float Ks = 0.5;
static const float Kr = 0.5;
static const float SpecularExponent = 32.0;

TZ_TEXTURE2D_DECLARE(diffuse)
{
    MinFilter = LinearMipMapNearest;
    MagFilter = Linear;
    WrapS = Repeat;
    WrapT = Repeat;
    MaxAnisotropy = 16;
};

TZ_TEXTURE2D_DECLARE(normal_map)
{
    MinFilter = LinearMipMapNearest;
    MagFilter = Linear;
    WrapS = Repeat;
    WrapT = Repeat;
    MaxAnisotropy = 16;
};

TZ_TEXTURE2D_DECLARE(specular_map)
{
    MinFilter = LinearMipMapNearest;
    MagFilter = Linear;
    WrapS = Repeat;
    WrapT = Repeat;
    MaxAnisotropy = 16;
};

TZ_TEXTURE2D_DECLARE(glow_map)
{
    MinFilter = LinearMipMapNearest;
    MagFilter = Linear;
    WrapS = Repeat;
    WrapT = Repeat;
};

TZ_TEXTURE2D_DECLARE(alpha_map)
{
    MinFilter = LinearMipMapNearest;
    MagFilter = Linear;
    WrapS = Repeat;
    WrapT = Repeat;
    MaxAnisotropy = 16;
};

TZ_TEXTURECUBE_DECLARE(env_map)
{
    MinFilter = LinearMipMapNearest;
    MagFilter = Linear;
    WrapS = ClampToEdge;
    WrapT = ClampToEdge;
    WrapR = ClampToEdge;
};

TZ_TEXTURE2D_DECLARE(light_map)
{
    MinFilter = LinearMipMapNearest;
    MagFilter = Linear;
    WrapS = ClampToEdge;
    WrapT = ClampToEdge;
};

//
// Utils
//

float4 PointToDevice(float3 pt, float4x4 transform)
{
    return pt.xxxx * transform[0] +
           pt.yyyy * transform[1] +
           pt.zzzz * transform[2] +
                     transform[3];
}

float3 NormalToWorld(float3 n, float3x3 transform)
{
    return n.xxx * transform[0] +
           n.yyy * transform[1] +
           n.zzz * transform[2];
}

void blinn_shading(float3 LightColor,
                   float3 Nn,
                   float3 Ln,
                   float3 Vn,
                   out float3 DiffuseContrib,
                   out float3 SpecularContrib)
{
    float3 Hn = normalize(Vn + Ln);
    float d = saturate(dot(Ln, Nn));
    float s = pow(saturate(dot(Hn, Nn)), SpecularExponent);
    DiffuseContrib = d * LightColor;
    SpecularContrib = float(d > 0.0) * s * Ks * LightColor;
}

void phong_shading(float3 LightColor,
                   float3 Nn,
                   float3 Ln,
                   float3 Vn,
                   out float3 DiffuseContrib,
                   out float3 SpecularContrib)
{
    float3 R = reflect(-Ln, Nn);
    float d = saturate(dot(Ln, Nn));
    float s = pow(saturate(dot(R, Vn)), SpecularExponent);
    DiffuseContrib = d * LightColor;
    SpecularContrib = float(d > 0.0) * s * Ks * LightColor;
}

void blinn_ks_shading(float3 LightColor,
                      float3 ks,
                      float3 Nn,
                      float3 Ln,
                      float3 Vn,
                      out float3 DiffuseContrib,
                      out float3 SpecularContrib)
{
    float3 Hn = normalize(Vn + Ln);
    float d = saturate(dot(Ln, Nn));
    float s = pow(saturate(dot(Hn, Nn)), SpecularExponent);
    DiffuseContrib = d * LightColor;
    SpecularContrib = float(d > 0.0) * s * ks * LightColor;
}

float3 SampleNormalMap(float2 uv)
{
    return normalize(2.0 * TZ_TEX2D(normal_map, uv).xyz - 1.0);
}

float3 SampleNormalMapRXGB(float2 uv)
{
    float3 normal;
    //normal = (2.0 * TZ_TEX2D(normal_map, uv).xyz - 1.0);
    normal = normalize(2.0 * TZ_TEX2D(normal_map, uv).agb - 1.0);
    //normal.xy = (2.0 * TZ_TEX2D(normal_map, uv).ag - 1.0);
    //normal.z = sqrt(1.0 - (normal.x * normal.x) - (normal.y * normal.y));
    return normal;
}

//
// Vertex programs
//
void vp_nolight(in float3 INPosition : POSITION,
                in float2 INUV       : TEXCOORD0,
                out float4 OUTPosition : TZ_OUT_POSITION,
                out float2 OUTUV       : TEXCOORD0)
{
    OUTPosition = PointToDevice(INPosition, worldViewProjection);
    OUTUV = TransformUV(INUV);
}

void vp_nolight_skinned(in float3 INPosition : POSITION,
                        in float2 INUV       : TEXCOORD0,
                        in TZ_ATTR_UINT4 INIndices  : BLENDINDICES,
                        in float4 INWeights  : BLENDWEIGHT,
                        out float4 OUTPosition : TZ_OUT_POSITION,
                        out float2 OUTUV       : TEXCOORD0)
{
    float3x4 skinMatrix = BuildSkinMatrix(INIndices, INWeights);

    float4 skinTempPosition = float4(INPosition, 1.0);
    float3 Position;
    Position.x = dot(skinTempPosition, skinMatrix[0]);
    Position.y = dot(skinTempPosition, skinMatrix[1]);
    Position.z = dot(skinTempPosition, skinMatrix[2]);

    OUTPosition = PointToDevice(Position, worldViewProjection);
    OUTUV = TransformUV(INUV);
}

void vp_nolight_vertexcolor(in float3 INPosition : POSITION,
                            in float2 INUV       : TEXCOORD0,
                            in float4 INColor    : COLOR,
                            out float4 OUTPosition : TZ_OUT_POSITION,
                            out float4 OUTColor    : COLOR,
                            out float2 OUTUV       : TEXCOORD0)
{
    OUTPosition = PointToDevice(INPosition, worldViewProjection);
    OUTColor = float4(INColor.xyz * materialColor.xyz, INColor.w);
    OUTUV = TransformUV(INUV);
}

void vp_skybox(in float3 INPosition : POSITION,
               out float4 OUTPosition     : TZ_OUT_POSITION,
               out float3 OUTEyeDirection : TEXCOORD0)
{
    OUTPosition = PointToDevice(INPosition, worldViewProjection);
    OUTEyeDirection = NormalToWorld((INPosition - eyePosition), worldInverseTranspose);
}

void vp_glass_env(in float3 INPosition : POSITION,
                  in float3 INNormal   : NORMAL,
                  in float2 INUV       : TEXCOORD0,
                  out float4 OUTPosition     : TZ_OUT_POSITION,
                  out float2 OUTUV           : TEXCOORD0,
                  out float3 OUTNormal       : TEXCOORD1,
                  out float3 OUTEyeDirection : TEXCOORD2)
{
    OUTPosition = PointToDevice(INPosition, worldViewProjection);
    OUTUV = TransformUV(INUV);
    OUTNormal = NormalToWorld(INNormal, worldInverseTranspose);
    OUTEyeDirection = NormalToWorld((INPosition - eyePosition), worldInverseTranspose);
}

void vp_env(in float3 INPosition : POSITION,
            in float3 INNormal   : NORMAL,
            out float4 OUTPosition     : TZ_OUT_POSITION,
            out float3 OUTNormal       : TEXCOORD0,
            out float3 OUTEyeDirection : TEXCOORD1)
{
    OUTPosition = PointToDevice(INPosition, worldViewProjection);
    OUTNormal = NormalToWorld(INNormal, worldInverseTranspose);
    OUTEyeDirection = NormalToWorld((INPosition - eyePosition), worldInverseTranspose);
}

void vp_env_skinned(in float3 INPosition : POSITION,
                    in float3 INNormal   : NORMAL,
                    in TZ_ATTR_UINT4 INIndices  : BLENDINDICES,
                    in float4 INWeights  : BLENDWEIGHT,
                    out float4 OUTPosition     : TZ_OUT_POSITION,
                    out float3 OUTNormal       : TEXCOORD0,
                    out float3 OUTEyeDirection : TEXCOORD1)
{
    float3x4 skinMatrix = BuildSkinMatrix(INIndices, INWeights);

    float4 skinTempPosition = float4(INPosition, 1.0);
    float3 skinTempNormal = INNormal.xyz;
    float3 Position, Normal;
    Position.x = dot(skinTempPosition, skinMatrix[0]);
    Position.y = dot(skinTempPosition, skinMatrix[1]);
    Position.z = dot(skinTempPosition, skinMatrix[2]);
    Normal.x = dot(skinTempNormal, skinMatrix[0].xyz);
    Normal.y = dot(skinTempNormal, skinMatrix[1].xyz);
    Normal.z = dot(skinTempNormal, skinMatrix[2].xyz);

    OUTPosition = PointToDevice(Position, worldViewProjection);
    OUTNormal = NormalToWorld(Normal, worldInverseTranspose);
    OUTEyeDirection = NormalToWorld((Position - eyePosition), worldInverseTranspose);
}

void vp_flat(in float3 INPosition : POSITION,
             in float3 INNormal   : NORMAL,
             out float4 OUTPosition : TZ_OUT_POSITION,
             out float4 OUTColor    : COLOR)
{
    OUTPosition = PointToDevice(INPosition, worldViewProjection);
    float3 lv = normalize(lightPosition - INPosition);
    float3 color = (saturate(dot(INNormal, lv)) * lightColor + ambientColor);
    OUTColor = float4(color * materialColor.xyz, materialColor.w);
}

void vp_flat_skinned(in float3 INPosition : POSITION,
                     in float3 INNormal   : NORMAL,
                     in TZ_ATTR_UINT4 INIndices  : BLENDINDICES,
                     in float4 INWeights  : BLENDWEIGHT,
                     out float4 OUTPosition : TZ_OUT_POSITION,
                     out float4 OUTColor    : COLOR)
{
    float3x4 skinMatrix = BuildSkinMatrix(INIndices, INWeights);

    float4 skinTempPosition = float4(INPosition, 1.0);
    float3 skinTempNormal = INNormal.xyz;

    float3 Position, Normal;
    Position.x = dot(skinTempPosition, skinMatrix[0]);
    Position.y = dot(skinTempPosition, skinMatrix[1]);
    Position.z = dot(skinTempPosition, skinMatrix[2]);
    Normal.x = dot(skinTempNormal, skinMatrix[0].xyz);
    Normal.y = dot(skinTempNormal, skinMatrix[1].xyz);
    Normal.z = dot(skinTempNormal, skinMatrix[2].xyz);
    Normal = normalize(Normal);

    OUTPosition = PointToDevice(Position, worldViewProjection);
    float3 lv = normalize(lightPosition - Position);
    float3 color = (saturate(dot(Normal, lv)) * lightColor + ambientColor);
    OUTColor = float4(color * materialColor.xyz, materialColor.w);
}

void vp_lambert(in float3 INPosition : POSITION,
                in float3 INNormal   : NORMAL,
                in float2 INUV       : TEXCOORD0,
                out float4 OUTPosition : TZ_OUT_POSITION,
                out float4 OUTColor    : COLOR,
                out float2 OUTUV       : TEXCOORD0)
{
    OUTPosition = PointToDevice(INPosition, worldViewProjection);
    float3 lv = normalize(lightPosition - INPosition);
    float3 color = (saturate(dot(INNormal, lv)) * lightColor + ambientColor);
    OUTColor = float4(color * materialColor.xyz, materialColor.w);
    OUTUV = TransformUV(INUV);
}

void vp_lambert_skinned(in float3 INPosition : POSITION,
                        in float3 INNormal   : NORMAL,
                        in float2 INUV       : TEXCOORD0,
                        in TZ_ATTR_UINT4 INIndices  : BLENDINDICES,
                        in float4 INWeights  : BLENDWEIGHT,
                        out float4 OUTPosition : TZ_OUT_POSITION,
                        out float4 OUTColor    : COLOR,
                        out float2 OUTUV       : TEXCOORD0)
{
    float3x4 skinMatrix = BuildSkinMatrix(INIndices, INWeights);

    float4 skinTempPosition = float4(INPosition, 1.0);
    float3 skinTempNormal = INNormal.xyz;

    float3 Position, Normal;
    Position.x = dot(skinTempPosition, skinMatrix[0]);
    Position.y = dot(skinTempPosition, skinMatrix[1]);
    Position.z = dot(skinTempPosition, skinMatrix[2]);
    Normal.x = dot(skinTempNormal, skinMatrix[0].xyz);
    Normal.y = dot(skinTempNormal, skinMatrix[1].xyz);
    Normal.z = dot(skinTempNormal, skinMatrix[2].xyz);
    Normal = normalize(Normal);

    OUTPosition = PointToDevice(Position, worldViewProjection);
    float3 lv = normalize(lightPosition - Position);
    float3 color = (saturate(dot(Normal, lv)) * lightColor + ambientColor);
    OUTColor = float4(color * materialColor.xyz, materialColor.w);
    OUTUV = TransformUV(INUV);
}

void vp_blinn(in float3 INPosition : POSITION,
              in float3 INNormal   : NORMAL,
              in float2 INUV       : TEXCOORD0,
              out float4 OUTPosition : TZ_OUT_POSITION,
              out float2 OUTUV       : TEXCOORD0,
              out float3 OUTNormal   : TEXCOORD1,
              out float3 OUTLight    : TEXCOORD2,
              out float3 OUTView     : TEXCOORD3)
{
    OUTPosition = PointToDevice(INPosition, worldViewProjection);
    OUTUV = TransformUV(INUV);
    OUTNormal = INNormal;
    OUTLight = normalize(lightPosition - INPosition);
    OUTView  = normalize(eyePosition - INPosition);
}

void vp_blinn_skinned(in float3 INPosition : POSITION,
                      in float3 INNormal   : NORMAL,
                      in float2 INUV       : TEXCOORD0,
                      in TZ_ATTR_UINT4 INIndices  : BLENDINDICES,
                      in float4 INWeights  : BLENDWEIGHT,
                      out float4 OUTPosition : TZ_OUT_POSITION,
                      out float2 OUTUV       : TEXCOORD0,
                      out float3 OUTNormal   : TEXCOORD1,
                      out float3 OUTLight    : TEXCOORD2,
                      out float3 OUTView     : TEXCOORD3)
{
    float3x4 skinMatrix = BuildSkinMatrix(INIndices, INWeights);

    float4 skinTempPosition = float4(INPosition, 1.0);
    float3 skinTempNormal = INNormal.xyz;
    float3 Position, Normal;
    Position.x = dot(skinTempPosition, skinMatrix[0]);
    Position.y = dot(skinTempPosition, skinMatrix[1]);
    Position.z = dot(skinTempPosition, skinMatrix[2]);
    Normal.x = dot(skinTempNormal, skinMatrix[0].xyz);
    Normal.y = dot(skinTempNormal, skinMatrix[1].xyz);
    Normal.z = dot(skinTempNormal, skinMatrix[2].xyz);

    Normal.xyz = normalize(Normal.xyz);

    OUTPosition = PointToDevice(Position, worldViewProjection);
    OUTUV = TransformUV(INUV);
    OUTNormal = Normal;
    OUTLight = normalize(lightPosition - Position);
    OUTView  = normalize(eyePosition - Position);
}

void vp_normalmap(in float3 INPosition : POSITION,
                  in float3 INNormal   : NORMAL,
                  in float2 INUV       : TEXCOORD0,
                  in float3 INTangent  : TANGENT,
                  in float3 INBinormal : BINORMAL,
                  out float4 OUTPosition : TZ_OUT_POSITION,
                  out float2 OUTUV       : TEXCOORD0,
                  out float3 OUTLight    : TEXCOORD1,
                  out float3 OUTView     : TEXCOORD2)
{
    OUTPosition = PointToDevice(INPosition, worldViewProjection);
    OUTUV = TransformUV(INUV);
    float3 Nn = INNormal;
    float3 Tn = INTangent;
    float3 Bn = INBinormal;
    float3 Ln = normalize(lightPosition - INPosition);
    float3 Vn = normalize(eyePosition - INPosition);
    OUTLight = float3(dot(Ln, Tn), dot(Ln, Bn), dot(Ln, Nn));
    OUTView  = float3(dot(Vn, Tn), dot(Vn, Bn), dot(Vn, Nn));
}

void vp_normalmap_skinned(in float3 INPosition : POSITION,
                          in float3 INNormal   : NORMAL,
                          in float2 INUV       : TEXCOORD0,
                          in float3 INTangent  : TANGENT,
                          in float3 INBinormal : BINORMAL,
                          in TZ_ATTR_UINT4 INIndices  : BLENDINDICES,
                          in float4 INWeights  : BLENDWEIGHT,
                          out float4 OUTPosition : TZ_OUT_POSITION,
                          out float2 OUTUV       : TEXCOORD0,
                          out float3 OUTLight    : TEXCOORD1,
                          out float3 OUTView     : TEXCOORD2)
{
    float3x4 skinMatrix = BuildSkinMatrix(INIndices, INWeights);

    float4 skinTempPosition = float4(INPosition, 1.0);
    float3 skinTempNormal = INNormal.xyz;
    float3 skinTempTangent = INTangent.xyz;
    float3 skinTempBinormal = INBinormal.xyz;

    float3 Position, Normal, Tangent, Binormal;
    Position.x = dot(skinTempPosition, skinMatrix[0]);
    Position.y = dot(skinTempPosition, skinMatrix[1]);
    Position.z = dot(skinTempPosition, skinMatrix[2]);
    Normal.x = dot(skinTempNormal, skinMatrix[0].xyz);
    Normal.y = dot(skinTempNormal, skinMatrix[1].xyz);
    Normal.z = dot(skinTempNormal, skinMatrix[2].xyz);
    Tangent.x = dot(skinTempTangent, skinMatrix[0].xyz);
    Tangent.y = dot(skinTempTangent, skinMatrix[1].xyz);
    Tangent.z = dot(skinTempTangent, skinMatrix[2].xyz);
    Binormal.x = dot(skinTempBinormal, skinMatrix[0].xyz);
    Binormal.y = dot(skinTempBinormal, skinMatrix[1].xyz);
    Binormal.z = dot(skinTempBinormal, skinMatrix[2].xyz);

    Normal.xyz = normalize(Normal.xyz);
    Tangent.xyz = normalize(Tangent.xyz);
    Binormal.xyz = normalize(Binormal.xyz);

    OUTPosition = PointToDevice(Position, worldViewProjection);
    OUTUV = TransformUV(INUV);
    float3 Nn = Normal;
    float3 Tn = Tangent;
    float3 Bn = Binormal;
    float3 Ln = normalize(lightPosition - Position);
    float3 Vn = normalize(eyePosition - Position);
    OUTLight = float3(dot(Ln, Tn), dot(Ln, Bn), dot(Ln, Nn));
    OUTView  = float3(dot(Vn, Tn), dot(Vn, Bn), dot(Vn, Nn));
}

void vp_glowmap(in float3 INPosition : POSITION,
                in float2 INUV       : TEXCOORD0,
                out float4 OUTPosition : TZ_OUT_POSITION,
                out float2 OUTUV       : TEXCOORD0)
{
    OUTPosition = PointToDevice(INPosition, worldViewProjection);
    OUTUV = TransformUV(INUV);
}

void vp_glowmap_skinned(in float3 INPosition : POSITION,
                        in float2 INUV       : TEXCOORD0,
                        in TZ_ATTR_UINT4 INIndices  : BLENDINDICES,
                        in float4 INWeights  : BLENDWEIGHT,
                        out float4 OUTPosition : TZ_OUT_POSITION,
                        out float2 OUTUV       : TEXCOORD0)
{
    float3x4 skinMatrix = BuildSkinMatrix(INIndices, INWeights);

    float4 skinTempPosition = float4(INPosition, 1.0);

    float3 Position;
    Position.x = dot(skinTempPosition, skinMatrix[0]);
    Position.y = dot(skinTempPosition, skinMatrix[1]);
    Position.z = dot(skinTempPosition, skinMatrix[2]);

    OUTPosition = PointToDevice(Position, worldViewProjection);
    OUTUV = TransformUV(INUV);
}

void vp_lightmap(in float3 INPosition : POSITION,
                 in float2 INUV0      : TEXCOORD0,
                 in float2 INUV1      : TEXCOORD1,
                 out float4 OUTPosition : TZ_OUT_POSITION,
                 out float4 OUTUV       : TEXCOORD0)
{
    OUTPosition = PointToDevice(INPosition, worldViewProjection);
    OUTUV.xy = TransformUV(INUV0);
    OUTUV.zw = TransformUV(INUV1);
}

void vp_debug(in float3 INPosition : POSITION,
              in float3 INNormal   : NORMAL,
              in float2 INUV       : TEXCOORD0,
              in float3 INTangent  : TANGENT,
              in float3 INBinormal : BINORMAL,
              out float4 OUTPosition : TZ_OUT_POSITION,
              out float3 OUTNormal   : TEXCOORD0)
{
    OUTPosition = PointToDevice(INPosition, worldViewProjection);
    float3 Nn = NormalToWorld(INNormal, worldInverseTranspose);
    //float3 Tn = NormalToWorld(INTangent, worldInverseTranspose);
    //float3 Bn = NormalToWorld(INBinormal, worldInverseTranspose);
    OUTNormal = Nn;
}

void vp_debug_skinned(in float3 INPosition : POSITION,
                      in float3 INNormal   : NORMAL,
                      in float2 INUV       : TEXCOORD0,
                      in float3 INTangent  : TANGENT,
                      in float3 INBinormal : BINORMAL,
                      in TZ_ATTR_UINT4 INIndices  : BLENDINDICES,
                      in float4 INWeights  : BLENDWEIGHT,
                      out float4 OUTPosition : TZ_OUT_POSITION,
                      out float3 OUTNormal   : TEXCOORD0)
{
    float3x4 skinMatrix = BuildSkinMatrix(INIndices, INWeights);

    float4 skinTempPosition = float4(INPosition, 1.0);
    float3 skinTempNormal = INNormal.xyz;
    float3 skinTempTangent = INTangent.xyz;
    float3 skinTempBinormal = INBinormal.xyz;

    float3 Position, Normal, Tangent, Binormal;
    Position.x = dot(skinTempPosition, skinMatrix[0]);
    Position.y = dot(skinTempPosition, skinMatrix[1]);
    Position.z = dot(skinTempPosition, skinMatrix[2]);
    Normal.x = dot(skinTempNormal, skinMatrix[0].xyz);
    Normal.y = dot(skinTempNormal, skinMatrix[1].xyz);
    Normal.z = dot(skinTempNormal, skinMatrix[2].xyz);
    Tangent.x = dot(skinTempTangent, skinMatrix[0].xyz);
    Tangent.y = dot(skinTempTangent, skinMatrix[1].xyz);
    Tangent.z = dot(skinTempTangent, skinMatrix[2].xyz);
    Binormal.x = dot(skinTempBinormal, skinMatrix[0].xyz);
    Binormal.y = dot(skinTempBinormal, skinMatrix[1].xyz);
    Binormal.z = dot(skinTempBinormal, skinMatrix[2].xyz);

    Normal.xyz = normalize(Normal.xyz);
    Tangent.xyz = normalize(Tangent.xyz);
    Binormal.xyz = normalize(Binormal.xyz);

    OUTPosition = PointToDevice(Position, worldViewProjection);
    float3 Nn = NormalToWorld(Normal, worldInverseTranspose);
    //float3 Tn = NormalToWorld(Tangent, worldInverseTranspose);
    //float3 Bn = NormalToWorld(Binormal, worldInverseTranspose);
    OUTNormal = Nn;
}

//
// Fragment programs
//
float4 fp_normal(float2 INUV : TEXCOORD0) : TZ_OUT_COLOR
{
    return materialColor * TZ_TEX2D(diffuse, INUV);
}

float4 fp_normal_vertexcolor(float4 INColor : COLOR,
                             float2 INUV    : TEXCOORD0) : TZ_OUT_COLOR
{
    return INColor * TZ_TEX2D(diffuse, INUV);
}

float4 fp_translucent(float2 INUV : TEXCOORD0) : TZ_OUT_COLOR
{
    return float4(TZ_TEX2D(diffuse, INUV).xyz * materialColor.xyz, 1.0);
}

float4 fp_translucent_vertexcolor(float4 INColor : COLOR,
                                  float2 INUV    : TEXCOORD0) : TZ_OUT_COLOR
{
    return float4(TZ_TEX2D(diffuse, INUV).xyz * INColor.xyz, 1.0);
}

float4 fp_premodulatealpha(float2 INUV : TEXCOORD0) : TZ_OUT_COLOR
{
    float4 color = materialColor * TZ_TEX2D(diffuse, INUV);
    color.xyz *= materialColor.w;
    return color;
}

float4 fp_premodulatealpha_vertexcolor(float4 INColor : COLOR,
                                       float2 INUV    : TEXCOORD0) : TZ_OUT_COLOR
{
    float4 color = INColor * TZ_TEX2D(diffuse, INUV);
    color.xyz *= INColor.w;
    return color;
}

float4 fp_separatealpha(float2 INUV : TEXCOORD0) : TZ_OUT_COLOR
{
    float alpha = materialColor.w * TZ_TEX2D(alpha_map, INUV).a;
    return materialColor * TZ_TEX2D(diffuse, INUV) * alpha;
}

float4 fp_separatealpha_env(float2 INUV           : TEXCOORD0,
                            float3 INNormal       : TEXCOORD1,
                            float3 INEyeDirection : TEXCOORD2) : TZ_OUT_COLOR
{
    float alpha = materialColor.w * TZ_TEX2D(alpha_map, INUV).a;
    float3 R = reflect(normalize(INEyeDirection), normalize(INNormal));
    return materialColor * TZ_TEXCUBE(env_map, R) * alpha;
}

float4 fp_env(float3 INNormal       : TEXCOORD0,
              float3 INEyeDirection : TEXCOORD1) : TZ_OUT_COLOR
{
    float3 R = reflect(normalize(INEyeDirection), normalize(INNormal));
    return materialColor.w * materialColor * TZ_TEXCUBE(env_map, R);
}

float4 fp_flat(float4 INColor : COLOR) : TZ_OUT_COLOR
{
    return INColor;
}

float4 fp_lambert(float4 INColor : COLOR,
                  float2 INUV    : TEXCOORD0) : TZ_OUT_COLOR
{
    return INColor * TZ_TEX2D(diffuse, INUV);
}

float4 fp_blinn(float2 INUV     : TEXCOORD0,
                float3 INNormal : TEXCOORD1,
                float3 INLight  : TEXCOORD2,
                float3 INView   : TEXCOORD3) : TZ_OUT_COLOR
{
    float3 diffContrib;
    float3 specContrib;
    float3 Nn = normalize(INNormal);
    float3 Ln = normalize(INLight);
    float3 Vn = normalize(INView);
    blinn_shading(lightColor, Nn, Ln, Vn, diffContrib, specContrib);
    float4 diffuseColor = materialColor * TZ_TEX2D(diffuse, INUV);
    float3 result = specContrib + (diffuseColor.xyz * (diffContrib + ambientColor));
    return float4(result, diffuseColor.w);
}

float4 fp_phong(float2 INUV     : TEXCOORD0,
                float3 INNormal : TEXCOORD1,
                float3 INLight  : TEXCOORD2,
                float3 INView   : TEXCOORD3) : TZ_OUT_COLOR
{
    float3 diffContrib;
    float3 specContrib;
    float3 Nn = normalize(INNormal);
    float3 Ln = normalize(INLight);
    float3 Vn = normalize(INView);
    phong_shading(lightColor, Nn, Ln, Vn, diffContrib, specContrib);
    float3 diffuseColor = TZ_TEX2D(diffuse, INUV).rgb;
    float3 result = specContrib + (diffuseColor * (diffContrib + ambientColor));
    return float4(result,1.0);
}

float4 fp_normalmap(float2 INUV    : TEXCOORD0,
                    float3 INLight : TEXCOORD1,
                    float3 INView  : TEXCOORD2) : TZ_OUT_COLOR
{
    float3 diffContrib;
    float3 specContrib;
    float3 Ln = normalize(INLight);
    float3 Vn = normalize(INView);
    float3 Nn = SampleNormalMap(INUV);
    blinn_shading(lightColor, Nn, Ln, Vn, diffContrib, specContrib);
    float4 diffuseColor = materialColor * TZ_TEX2D(diffuse, INUV);
    float3 result = specContrib + (diffuseColor.xyz * (diffContrib + ambientColor));
    return float4(result, diffuseColor.w);
}

float4 fp_normalmap_alphatest(float2 INUV    : TEXCOORD0,
                              float3 INLight : TEXCOORD1,
                              float3 INView  : TEXCOORD2) : TZ_OUT_COLOR
{
    float4 diffuseColor = materialColor * TZ_TEX2D(diffuse, INUV);
    if (diffuseColor.a < alphaRef)
    {
        discard;
    }
    float3 diffContrib;
    float3 specContrib;
    float3 Ln = normalize(INLight);
    float3 Vn = normalize(INView);
    float3 Nn = SampleNormalMap(INUV);
    blinn_shading(lightColor, Nn, Ln, Vn, diffContrib, specContrib);
    float3 result = specContrib + (diffuseColor.xyz * (diffContrib + ambientColor));
    return float4(result, diffuseColor.w);
}

float4 fp_normalmap_specularmap(float2 INUV    : TEXCOORD0,
                                float3 INLight : TEXCOORD1,
                                float3 INView  : TEXCOORD2) : TZ_OUT_COLOR
{
    float3 diffContrib;
    float3 specContrib;
    float3 Ln = normalize(INLight);
    float3 Vn = normalize(INView);
    float3 Nn = SampleNormalMap(INUV);
    float3 ks = materialColor.xyz * TZ_TEX2D(specular_map, INUV).xyz;
    blinn_ks_shading(lightColor, ks, Nn, Ln, Vn, diffContrib, specContrib);
    float4 diffuseColor = materialColor * TZ_TEX2D(diffuse, INUV);
    float3 result = specContrib + (diffuseColor.xyz * (diffContrib + ambientColor));
    return float4(result, diffuseColor.w);
}

float4 fp_normalmap_specularmap_alphatest(float2 INUV    : TEXCOORD0,
                                          float3 INLight : TEXCOORD1,
                                          float3 INView  : TEXCOORD2) : TZ_OUT_COLOR
{
    float4 diffuseColor = materialColor * TZ_TEX2D(diffuse, INUV);
    if (diffuseColor.a < alphaRef)
    {
        discard;
    }
    float3 diffContrib;
    float3 specContrib;
    float3 Ln = normalize(INLight);
    float3 Vn = normalize(INView);
    float3 Nn = SampleNormalMap(INUV);
    float3 ks = materialColor.xyz * TZ_TEX2D(specular_map, INUV).xyz;
    blinn_ks_shading(lightColor, ks, Nn, Ln, Vn, diffContrib, specContrib);
    float3 result = specContrib + (diffuseColor.xyz * (diffContrib + ambientColor));
    return float4(result, diffuseColor.w);
}

float4 fp_normalmap_specularmap_alphamap(float2 INUV    : TEXCOORD0,
                                         float3 INLight : TEXCOORD1,
                                         float3 INView  : TEXCOORD2) : TZ_OUT_COLOR
{
    float alpha = materialColor.w * TZ_TEX2D(alpha_map, INUV).a;
    if (alpha < alphaRef)
    {
        discard;
    }
    float3 diffContrib;
    float3 specContrib;
    float3 Ln = normalize(INLight);
    float3 Vn = normalize(INView);
    float3 Nn = SampleNormalMap(INUV);
    float3 ks = materialColor.xyz * TZ_TEX2D(specular_map, INUV).xyz;
    blinn_ks_shading(lightColor, ks, Nn, Ln, Vn, diffContrib, specContrib);
    float3 diffuseColor = materialColor.xyz * TZ_TEX2D(diffuse, INUV).xyz;
    float3 result = specContrib + (diffuseColor * (diffContrib + ambientColor));
    return float4(result, alpha);
}

float4 fp_normalmap_glowmap(float2 INUV    : TEXCOORD0,
                            float3 INLight : TEXCOORD1,
                            float3 INView  : TEXCOORD2) : TZ_OUT_COLOR
{
    float3 diffContrib;
    float3 specContrib;
    float3 Ln = normalize(INLight);
    float3 Vn = normalize(INView);
    float3 Nn = SampleNormalMap(INUV);
    blinn_shading(lightColor, Nn, Ln, Vn, diffContrib, specContrib);
    float3 diffuseColor = TZ_TEX2D(diffuse, INUV).xyz;
    float3 glowColor = materialColor.xyz * TZ_TEX2D(glow_map, INUV).xyz;
    float3 result = (specContrib + (diffuseColor * (diffContrib + ambientColor)) + glowColor);
    return float4(result, 1.0);
}

float4 fp_normalmap_specularmap_glowmap(float2 INUV    : TEXCOORD0,
                                        float3 INLight : TEXCOORD1,
                                        float3 INView  : TEXCOORD2) : TZ_OUT_COLOR
{
    float3 diffContrib;
    float3 specContrib;
    float3 Ln = normalize(INLight);
    float3 Vn = normalize(INView);
    float3 Nn = SampleNormalMap(INUV);
    float3 ks = TZ_TEX2D(specular_map, INUV).xyz;
    blinn_ks_shading(lightColor, ks, Nn, Ln, Vn, diffContrib, specContrib);
    float3 diffuseColor = TZ_TEX2D(diffuse, INUV).xyz;
    float3 glowColor = materialColor.xyz * TZ_TEX2D(glow_map, INUV).xyz;
    float3 result = (specContrib + (diffuseColor * (diffContrib + ambientColor)) + glowColor);
    return float4(result, 1.0);
}

float4 fp_rxgb_normalmap(float2 INUV    : TEXCOORD0,
                         float3 INLight : TEXCOORD1,
                         float3 INView  : TEXCOORD2) : TZ_OUT_COLOR
{
    float3 diffContrib;
    float3 specContrib;
    float3 Ln = normalize(INLight);
    float3 Vn = normalize(INView);
    float3 Nn = SampleNormalMapRXGB(INUV);
    blinn_shading(lightColor, Nn, Ln, Vn, diffContrib, specContrib);
    float4 diffuseColor = materialColor * TZ_TEX2D(diffuse, INUV);
    float3 result = specContrib + (diffuseColor.xyz * (diffContrib + ambientColor));
    return float4(result, diffuseColor.w);
}

float4 fp_rxgb_normalmap_alphatest(float2 INUV    : TEXCOORD0,
                                   float3 INLight : TEXCOORD1,
                                   float3 INView  : TEXCOORD2) : TZ_OUT_COLOR
{
    float4 diffuseColor = materialColor * TZ_TEX2D(diffuse, INUV);
    if (diffuseColor.a < alphaRef)
    {
        discard;
    }
    float3 diffContrib;
    float3 specContrib;
    float3 Ln = normalize(INLight);
    float3 Vn = normalize(INView);
    float3 Nn = SampleNormalMapRXGB(INUV);
    blinn_shading(lightColor, Nn, Ln, Vn, diffContrib, specContrib);
    float3 result = specContrib + (diffuseColor.xyz * (diffContrib + ambientColor));
    return float4(result, diffuseColor.w);
}

float4 fp_rxgb_normalmap_specularmap(float2 INUV    : TEXCOORD0,
                                     float3 INLight : TEXCOORD1,
                                     float3 INView  : TEXCOORD2) : TZ_OUT_COLOR
{
    float3 diffContrib;
    float3 specContrib;
    float3 Ln = normalize(INLight);
    float3 Vn = normalize(INView);
    float3 Nn = SampleNormalMapRXGB(INUV);
    float3 ks = materialColor.xyz * TZ_TEX2D(specular_map, INUV).xyz;
    blinn_ks_shading(lightColor, ks, Nn, Ln, Vn, diffContrib, specContrib);
    float4 diffuseColor = materialColor * TZ_TEX2D(diffuse, INUV);
    float3 result = specContrib + (diffuseColor.xyz * (diffContrib + ambientColor));
    return float4(result, diffuseColor.w);
}

float4 fp_rxgb_normalmap_specularmap_alphatest(float2 INUV    : TEXCOORD0,
                                               float3 INLight : TEXCOORD1,
                                               float3 INView  : TEXCOORD2)
    : TZ_OUT_COLOR
{
    float4 diffuseColor = materialColor * TZ_TEX2D(diffuse, INUV);
    if (diffuseColor.a < alphaRef)
    {
        discard;
    }
    float3 diffContrib;
    float3 specContrib;
    float3 Ln = normalize(INLight);
    float3 Vn = normalize(INView);
    float3 Nn = SampleNormalMapRXGB(INUV);
    float3 ks = materialColor.xyz * TZ_TEX2D(specular_map, INUV).xyz;
    blinn_ks_shading(lightColor, ks, Nn, Ln, Vn, diffContrib, specContrib);
    float3 result = specContrib + (diffuseColor.xyz * (diffContrib + ambientColor));
    return float4(result, diffuseColor.w);
}

float4 fp_rxgb_normalmap_glowmap(float2 INUV    : TEXCOORD0,
                                 float3 INLight : TEXCOORD1,
                                 float3 INView  : TEXCOORD2) : TZ_OUT_COLOR
{
    float3 diffContrib;
    float3 specContrib;
    float3 Ln = normalize(INLight);
    float3 Vn = normalize(INView);
    float3 Nn = SampleNormalMapRXGB(INUV);
    blinn_shading(lightColor, Nn, Ln, Vn, diffContrib, specContrib);
    float3 diffuseColor = TZ_TEX2D(diffuse, INUV).xyz;
    float3 glowColor = materialColor.xyz * TZ_TEX2D(glow_map, INUV).xyz;
    float3 result = (specContrib + (diffuseColor * (diffContrib + ambientColor)) + glowColor);
    return float4(result, materialColor.w);
}

float4 fp_rxgb_normalmap_specularmap_glowmap(float2 INUV    : TEXCOORD0,
                                             float3 INLight : TEXCOORD1,
                                             float3 INView  : TEXCOORD2)
    : TZ_OUT_COLOR
{
    float3 diffContrib;
    float3 specContrib;
    float3 Ln = normalize(INLight);
    float3 Vn = normalize(INView);
    float3 Nn = SampleNormalMapRXGB(INUV);
    float3 ks = TZ_TEX2D(specular_map, INUV).xyz;
    blinn_ks_shading(lightColor, ks, Nn, Ln, Vn, diffContrib, specContrib);
    float3 diffuseColor = TZ_TEX2D(diffuse, INUV).xyz;
    float3 glowColor = materialColor.xyz * TZ_TEX2D(glow_map, INUV).xyz;
    float3 result = (specContrib + (diffuseColor * (diffContrib + ambientColor)) + glowColor);
    return float4(result, materialColor.w);
}

float4 fp_glowmap(float2 INUV : TEXCOORD0) : TZ_OUT_COLOR
{
    return float4(materialColor.xyz * TZ_TEX2D(glow_map, INUV).xyz, 1.0);
}

float4 fp_lightmap(float4 INUV : TEXCOORD0) : TZ_OUT_COLOR
{
    float3 diffuseColor = TZ_TEX2D(diffuse, INUV.xy).xyz;
    float3 diffContrib = ((lightingScale * TZ_TEX2D(light_map, INUV.zw).xyz) + ambientColor);
    return float4(materialColor.xyz * diffuseColor * diffContrib, 1.0);
}

float4 fp_skybox(float3 INEyeDirection : TEXCOORD0) : TZ_OUT_COLOR
{
    return TZ_TEXCUBE(env_map, INEyeDirection);
}

float4 fp_debug(float3 INNormal : TEXCOORD0) : TZ_OUT_COLOR
{
    return float4(INNormal * 0.5 + 0.5, 1.0);
}

//
// Techniques
//
technique flat
{
    pass p0
    {
        DepthTestEnable = true;
        DepthFunc       = lequal;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_flat();
        FragmentProgram = compile latest fp_flat();
    }
}

technique flat_skinned
{
    pass p0
    {
        DepthTestEnable = true;
        DepthFunc       = lequal;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_flat_skinned();
        FragmentProgram = compile latest fp_flat();
    }
}

technique flat_nocull
{
    pass p0
    {
        DepthTestEnable = true;
        DepthFunc       = lequal;
        DepthMask       = true;
        CullFaceEnable  = false;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_flat();
        FragmentProgram = compile latest fp_flat();
    }
}

technique flat_skinned_nocull
{
    pass p0
    {
        DepthTestEnable = true;
        DepthFunc       = lequal;
        DepthMask       = true;
        CullFaceEnable  = false;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_flat_skinned();
        FragmentProgram = compile latest fp_flat();
    }
}

technique lambert
{
    pass p0
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_lambert();
        FragmentProgram = compile latest fp_lambert();
    }
}

technique lambert_skinned
{
    pass p0
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_lambert_skinned();
        FragmentProgram = compile latest fp_lambert();
    }
}

technique blinn
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_blinn();
        FragmentProgram = compile latest fp_blinn();
    }
}

technique blinn_nocull
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = false;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_blinn();
        FragmentProgram = compile latest fp_blinn();
    }
}

technique blinn_skinned
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_blinn_skinned();
        FragmentProgram = compile latest fp_blinn();
    }
}

technique blinn_skinned_nocull
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = false;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_blinn_skinned();
        FragmentProgram = compile latest fp_blinn();
    }
}

technique phong
{
    pass p0
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_blinn();
        FragmentProgram = compile latest fp_phong();
    }
}

technique phong_skinned
{
    pass p0
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_blinn_skinned();
        FragmentProgram = compile latest fp_phong();
    }
}

technique add
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = false;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = true;
        BlendFunc       = int2(One, One);
        PolygonOffset   = float2(-1.0, -1.0);
        PolygonOffsetFillEnable = true;

        VertexProgram   = compile latest vp_nolight();
        FragmentProgram = compile latest fp_premodulatealpha();
    }
}

technique add_skinned
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = false;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = true;
        BlendFunc       = int2(One, One);
        PolygonOffset   = float2(-1.0, -1.0);
        PolygonOffsetFillEnable = true;

        VertexProgram   = compile latest vp_nolight_skinned();
        FragmentProgram = compile latest fp_premodulatealpha();
    }
}

technique add_particle
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = false;
        CullFaceEnable  = false;
        BlendEnable     = true;
        BlendFunc       = int2(One, One);
        PolygonOffset   = float2(-1.0, -1.0);
        PolygonOffsetFillEnable = true;

        VertexProgram   = compile latest vp_nolight_vertexcolor();
        FragmentProgram = compile latest fp_premodulatealpha_vertexcolor();
    }
}

technique blend
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = false;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = true;
        BlendFunc       = int2(SrcAlpha, InvSrcAlpha);
        PolygonOffset   = float2(-1.0, -1.0);
        PolygonOffsetFillEnable = true;

        VertexProgram   = compile latest vp_nolight();
        FragmentProgram = compile latest fp_normal();
    }
}

technique blend_skinned
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = false;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = true;
        BlendFunc       = int2(SrcAlpha, InvSrcAlpha);
        PolygonOffset   = float2(-1.0, -1.0);
        PolygonOffsetFillEnable = true;

        VertexProgram   = compile latest vp_nolight_skinned();
        FragmentProgram = compile latest fp_normal();
    }
}

technique blend_particle
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = false;
        CullFaceEnable  = false;
        BlendEnable     = true;
        BlendFunc       = int2(SrcAlpha, InvSrcAlpha);
        PolygonOffset   = float2(-1.0, -1.0);
        PolygonOffsetFillEnable = true;

        VertexProgram   = compile latest vp_nolight_vertexcolor();
        FragmentProgram = compile latest fp_normal_vertexcolor();
    }
}

technique translucent
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = false;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = true;
        BlendFunc       = int2(One, One);
        PolygonOffset   = float2(-1.0, -1.0);
        PolygonOffsetFillEnable = true;

        VertexProgram   = compile latest vp_nolight();
        FragmentProgram = compile latest fp_translucent();
    }
}

technique translucent_skinned
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = false;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = true;
        BlendFunc       = int2(One, One);
        PolygonOffset   = float2(-1.0, -1.0);
        PolygonOffsetFillEnable = true;

        VertexProgram   = compile latest vp_nolight_skinned();
        FragmentProgram = compile latest fp_translucent();
    }
}

technique translucent_particle
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = false;
        CullFaceEnable  = false;
        BlendEnable     = true;
        BlendFunc       = int2(One, One);
        PolygonOffset   = float2(-1.0, -1.0);
        PolygonOffsetFillEnable = true;

        VertexProgram   = compile latest vp_nolight_vertexcolor();
        FragmentProgram = compile latest fp_translucent_vertexcolor();
    }
}

technique filter
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = false;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = true;
        BlendFunc       = int2(DestColor, Zero);
        PolygonOffset   = float2(-1.0, -1.0);
        PolygonOffsetFillEnable = true;

        VertexProgram   = compile latest vp_nolight();
        FragmentProgram = compile latest fp_normal();
    }
}

technique filter_skinned
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = false;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = true;
        BlendFunc       = int2(DestColor, Zero);
        PolygonOffset   = float2(-1.0, -1.0);
        PolygonOffsetFillEnable = true;

        VertexProgram   = compile latest vp_nolight_skinned();
        FragmentProgram = compile latest fp_normal();
    }
}

technique invfilter
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = false;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = true;
        BlendFunc       = int2(Zero, InvSrcColor);
        PolygonOffset   = float2(-1.0, -1.0);
        PolygonOffsetFillEnable = true;

        VertexProgram   = compile latest vp_nolight();
        FragmentProgram = compile latest fp_premodulatealpha();
    }
}

technique invfilter_particle
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = false;
        CullFaceEnable  = false;
        BlendEnable     = true;
        BlendFunc       = int2(Zero, InvSrcColor);
        PolygonOffset   = float2(-1.0, -1.0);
        PolygonOffsetFillEnable = true;

        VertexProgram   = compile latest vp_nolight_vertexcolor();
        FragmentProgram = compile latest fp_premodulatealpha_vertexcolor();
    }
}

technique glass
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = false;
        CullFaceEnable  = false;
        BlendEnable     = true;
        BlendFunc       = int2(One, One);

        VertexProgram   = compile latest vp_nolight();
        FragmentProgram = compile latest fp_separatealpha();
    }
}

technique glass_env
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = false;
        CullFaceEnable  = false;
        BlendEnable     = true;
        BlendFunc       = int2(One, One);

        VertexProgram   = compile latest vp_glass_env();
        FragmentProgram = compile latest fp_separatealpha_env();
    }
}

technique modulate2
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = false;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = true;
        BlendFunc       = int2(DestColor, SrcColor);
        PolygonOffset   = float2(-1.0, -1.0);
        PolygonOffsetFillEnable = true;

        VertexProgram   = compile latest vp_nolight();
        FragmentProgram = compile latest fp_normal();
    }
}

technique modulate2_skinned
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = false;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = true;
        BlendFunc       = int2(DestColor, SrcColor);
        PolygonOffset   = float2(-1.0, -1.0);
        PolygonOffsetFillEnable = true;

        VertexProgram   = compile latest vp_nolight_skinned();
        FragmentProgram = compile latest fp_normal();
    }
}

technique normalmap
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_normalmap();
        FragmentProgram = compile latest fp_normalmap();
    }
}

technique normalmap_specularmap
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_normalmap();
        FragmentProgram = compile latest fp_normalmap_specularmap();
    }
}

technique normalmap_specularmap_alphamap
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        StencilTestEnable = true;
        StencilFunc       = int3(Always, 0, 0xFFFFFFFF);
        StencilOp         = int3(Keep, Keep, Zero);
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_normalmap();
        FragmentProgram = compile latest fp_normalmap_specularmap_alphamap();
    }
}

technique normalmap_alphatest
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;

        VertexProgram   = compile latest vp_normalmap();
        FragmentProgram = compile latest fp_normalmap_alphatest();
    }
}

technique normalmap_specularmap_alphatest
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;

        VertexProgram   = compile latest vp_normalmap();
        FragmentProgram = compile latest fp_normalmap_specularmap_alphatest();
    }
}

technique normalmap_specularmap_glowmap
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_normalmap();
        FragmentProgram = compile latest fp_normalmap_specularmap_glowmap();
    }
}

technique normalmap_glowmap
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_normalmap();
        FragmentProgram = compile latest fp_normalmap_glowmap();
    }
}

technique normalmap_skinned
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_normalmap_skinned();
        FragmentProgram = compile latest fp_normalmap();
    }
}

technique normalmap_specularmap_skinned
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_normalmap_skinned();
        FragmentProgram = compile latest fp_normalmap_specularmap();
    }
}

technique normalmap_alphatest_skinned
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;

        VertexProgram   = compile latest vp_normalmap_skinned();
        FragmentProgram = compile latest fp_normalmap_alphatest();
    }
}

technique normalmap_specularmap_alphatest_skinned
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;

        VertexProgram   = compile latest vp_normalmap_skinned();
        FragmentProgram = compile latest fp_normalmap_specularmap_alphatest();
    }
}

technique normalmap_specularmap_glowmap_skinned
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_normalmap_skinned();
        FragmentProgram = compile latest fp_normalmap_specularmap_glowmap();
    }
}

technique normalmap_glowmap_skinned
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_normalmap_skinned();
        FragmentProgram = compile latest fp_normalmap_glowmap();
    }
}

technique rxgb_normalmap
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_normalmap();
        FragmentProgram = compile latest fp_rxgb_normalmap();
    }
}

technique rxgb_normalmap_specularmap
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_normalmap();
        FragmentProgram = compile latest fp_rxgb_normalmap_specularmap();
    }
}

technique rxgb_normalmap_alphatest
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;

        VertexProgram   = compile latest vp_normalmap();
        FragmentProgram = compile latest fp_rxgb_normalmap_alphatest();
    }
}

technique rxgb_normalmap_specularmap_alphatest
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;

        VertexProgram   = compile latest vp_normalmap();
        FragmentProgram = compile latest fp_rxgb_normalmap_specularmap_alphatest();
    }
}

technique rxgb_normalmap_specularmap_glowmap
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_normalmap();
        FragmentProgram = compile latest fp_rxgb_normalmap_specularmap_glowmap();
    }
}

technique rxgb_normalmap_glowmap
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_normalmap();
        FragmentProgram = compile latest fp_rxgb_normalmap_glowmap();
    }
}

technique rxgb_normalmap_skinned
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_normalmap_skinned();
        FragmentProgram = compile latest fp_rxgb_normalmap();
    }
}

technique rxgb_normalmap_specularmap_skinned
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_normalmap_skinned();
        FragmentProgram = compile latest fp_rxgb_normalmap_specularmap();
    }
}

technique rxgb_normalmap_alphatest_skinned
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;

        VertexProgram   = compile latest vp_normalmap_skinned();
        FragmentProgram = compile latest fp_rxgb_normalmap_alphatest();
    }
}

technique rxgb_normalmap_specularmap_alphatest_skinned
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;

        VertexProgram   = compile latest vp_normalmap_skinned();
        FragmentProgram = compile latest fp_rxgb_normalmap_specularmap_alphatest();
    }
}

technique rxgb_normalmap_specularmap_glowmap_skinned
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_normalmap_skinned();
        FragmentProgram = compile latest fp_rxgb_normalmap_specularmap_glowmap();
    }
}

technique rxgb_normalmap_glowmap_skinned
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_normalmap_skinned();
        FragmentProgram = compile latest fp_rxgb_normalmap_glowmap();
    }
}

technique glowmap
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_glowmap();
        FragmentProgram = compile latest fp_glowmap();
    }
}

technique glowmap_skinned
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_glowmap_skinned();
        FragmentProgram = compile latest fp_glowmap();
    }
}

technique skybox
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_skybox();
        FragmentProgram = compile latest fp_skybox();
    }
}

technique env
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = false;
        CullFaceEnable  = false;
        BlendEnable     = true;
        BlendFunc       = int2(One, One);

        VertexProgram   = compile latest vp_env();
        FragmentProgram = compile latest fp_env();
    }
}

technique env_skinned
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = false;
        CullFaceEnable  = false;
        BlendEnable     = true;
        BlendFunc       = int2(One, One);

        VertexProgram   = compile latest vp_env_skinned();
        FragmentProgram = compile latest fp_env();
    }
}

technique lightmap
{
    pass
    {
        DepthTestEnable = true;
        DepthFunc       = LEqual;
        DepthMask       = true;
        CullFaceEnable  = true;
        CullFace        = Back;
        BlendEnable     = false;

        VertexProgram   = compile latest vp_lightmap();
        FragmentProgram = compile latest fp_lightmap();
    }
}
